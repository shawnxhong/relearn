# 内存管理

## 虚拟内存
- 空分复用
- 虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

- 将内存抽象成地址空间
- 每个程序拥有自己的地址空间
- 地址空间被分割成多个块，每一块称为一页
- 页被离散地 部分地 映射到物理内存
- 要用不在物理内存中的页时
  - 将缺的页装入物理内存
  - 重新执行失败的指令

- 虚拟内存 不需要程序全部调入内存 就可以跑

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7b281b1e-0595-402b-ae35-8c91084c33c1.png)

## 分页系统地址映射

- 内存管理单元（MMU）管理着地址空间和物理内存的转换
  - 页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。

- 一个虚拟地址分成两个部分
  - 页面号
  - 偏移量


## 页面置换算法

- 如果要访问的页面不在内存中
  - 缺页中断 将该页调入内存中
- 如果内存 无空闲空间
  - os 从内存中 淘汰一个页面 放到到硬盘对换区 腾出空间

- 主要目标是
  - 页面置换频率最低
  - 缺页率最低

### 1. 最佳
> OPT, Optimal replacement algorithm
- 挑 最长时间内不会被访问的页面淘汰掉 
- 太理想化了 你咋知道 一个页面多长时间不再被访问

### 2. 最近最久未使用
> LRU, Least Recently Used

- LRU 将 淘汰 最近最久未使用的页面
- 内存中维护一个所有页面的链表
- 再维护一个哈希表 使搜索O(1)
- 当一个页面被访问时，将这个页面移到链表表头
- 保证链表表尾的页面是最近最久未访问的。

- 因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。


### 3. 最近未使用

> NRU, Not Recently Used
- 每个页面都有两个状态位：R 与 M
  - 页面被访问时 设置 R=1   R 位会定时被清零
  - 页面被修改时 设置 M=1
- 有四类页面
  - R=0，M=0    不常用 干净
  - R=0，M=1    不常用 脏
  - R=1，M=0    常用  干净
  - R=1，M=1    常用  脏

- 当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。

- NRU 优先换出已经被修改的脏页面（R=0，M=1）
- 被频繁使用的干净页面（R=1，M=0） 不太被换

### 4. 先进先出
> FIFO, First In First Out

- 选择换出的页面是最先进入的页面。
- 经常被访问的页面换出
  - 缺页率升高


## 分段

- 虚拟内存采用的是分页技术
  - 将地址空间划分成固定大小的页
  - 每一页再与内存进行映射

- 但是一个进程的空间地址还会增长 不是焊死不动的
- 所以要再拆开 拆成段
- 每个段 各自动态增长 像vector一样
- 否则 容易长着长着 互相冲突

- 分段的做法是把每个表分成段
  - 一个段构成一个独立的地址空间
  - 每个段的长度可以不同
  - 并且可以动态增长


## 段页式

- 程序的地址空间划分成多个拥有独立地址空间的段
- 每个段上的地址空间划分成大小相同的页
- 这样既拥有分段系统的共享和保护
- 又拥有分页系统的虚拟内存功能。

## 分页与分段的比较

- 对程序员的透明性
  - 分页透明 就是都一样
  - 分段 要显式划分每个段

- 地址空间的维度
  - 分页是一维地址空间
  - 分段是二维的

- 大小是否可以改变
  - 页的大小不可变
  - 段的大小可以动态改变

- 出现的原因
  - 分页主要用于实现虚拟内存，从而获得更大的地址空间
  - 分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护