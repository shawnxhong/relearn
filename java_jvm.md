# java

## 内存结构
- 运行时数据区
  - 虚拟机栈
  - 堆     (所有线程共享)
  - 本地方法栈
  - 方法区  (所有线程共享)
  - 程序计数器
- 执行引擎 (所有线程共享)
- 本地库接口 (所有线程共享)
- 本地方法库

### 程序计数器
- 本线程所执行的字节码的行号
- 分支，循环，跳转，异常处理，线程恢复
- 线程切换后，恢复到正确的执行位置，每个线程需要一个独立的程序计数器，即线程私有
- 不会出现OutOfMemoryError

### 虚拟机栈
- 两种异常
  - StackOverFlow
    - 如果jvm栈 内存大小不允许动态扩展，栈深度过深，就会爆栈
  - OutOfMemoryError
    - jvm栈内存大小允许扩展
    - 扩展的内存都用完了，就会报这个
- 线程私有，每个线程都有自己的jvm栈
- 随着线程创建而创建，死亡而死亡
- 当一个线程内部方法被执行
  - jvm创建一个Stack Frame
  - Stack Fram 入栈到虚拟机栈里
  - 储存局部变量表，操作数栈，动态链接，方法出口
    - 局部变量表：基本数据类型，对象引用，returnAddress

- 保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。

### 本地方法栈
- 与虚拟机栈的区别
  - 本地方法栈 为jvm 所使用的native方法服务
  - jvm栈为各个线程服务
  
### 堆
- 最大的一块内存
- 所有线程共享
- 唯一目的就是存放对象实例和数组
- GC的主要区域

### 方法区
- 所有线程共享
- 储存
  - 已被加载的类的信息
  - 常量
  - 静态变量
  - 即时编译器编译后的代码
- 基本不GC
- HotSpot里把这个叫 永久代

### 运行时常量池
- 字面量
  - 文本字符串
  - 被声明为final 的常量值
  - 基本数据类型的值
- 符号引用
  - 类和结构的完全限定名
  - 字段名称，描述符
  - 方法名称，描述符

### 直接内存
- 不是jvm 运行时数据区的一部分，但被频繁使用
- 可能会出现OutOfMemoryError


## HotSpot 对象分配，布局，访问
1. 类加载检查
- new 对象时，先检查常量池中，有没有这种符号引用
- 检查该class是否已被加载，解析和初始化过
- 若未被加载过，执行类加载过程

2. 分配内存
- 对象所需大小，在类加载完成后可以确定
- 两种分配方式
  - 指针碰撞 Bump the pointer
    - 对于规整的内存，左边都是占据，右边都是空闲，只要把指针往空闲区移动对象大小即可
  
  - 离散内存
  - Jvm 维护Free List空闲链表，寻找足够大的一块空闲内存new对象
  
  - 具体采用那种分配方式，取决与GC 是否进行空间压缩整理(Compact)
    - Serial, ParNew 带有Compact功能，采用Bump the pointer方式
    - CMS 采用 Sweep算法，会产生内存碎片，故采用空闲链表分配内存 
- 线程安全性
  - 并发情况下，可能出现，正在给对象A 分配内存，指针还没修改，对象B 又用原指针分配内存的情况
  - 解决方案
    1. 分配内存空间的操作 进行同步处理
       - CAS + 失败重试
       - 一种乐观锁
       - 每次不加锁，假设不会有冲突，直接去操作
       - 如果因冲突而失败，就反复重试，直至成功
       - 失败重试保证了原子性

    2. 把内存分配的动作 按照线程划分在不同的地址空间中 **TLAB**
       - 每个线程在java 堆中，预先分配一块内存
       - 即本地线程分配缓冲 thread local allocation buffer
       - 哪个线程要分配内存，就在哪个线程的buffer中分配
       - buffer用完后，分配新的buffer 需要同步锁定
3. 初始化零值
    - 完成内存分配后，jvm 将分配到的内存空间 都初始化为零值
    - 如果采用 TLAB 的方式，直接在buffer分配时提前化为零值

4. 设置对象头
    - 设置 这个对象是哪个类的实例
    - 如何能找到类的 元数据信息
    - 对象的 GC 分代年龄信息
    - 将以上信息存放在 Object Header中

5. 执行init方法
   - 执行构造函数

### 对象内存布局
- 对象在堆内存中分为 对象头Header, 实例数据 Instance Data, 对齐填充 Padding
- 对象头信息
  1. 对象运行时数据
    - hashcode
    - GC 分代年龄
    - 锁状态标志
    - 线程持有的锁
    - 偏向线程ID
    - 偏向时间戳
    - 这些东西总长 32 或 64 bite, 看是多少位的虚拟机
      - e.g. 32位 HotSpot中
        - 25 bite 存hash码, 4 bite 存年龄， 2bite 存储锁标志位， 1 bite 固定为0, 剩下为其他状态
  2. 类型指针
    - 指向类型元数据的指针
    - jvm 通过这个指针确定某个对象是什么class
    - 如果是数组，还要存 length
- 实例数据
- 对齐填充padding

### 对象的访问定位
- 通过引用，以定位访问到堆中的对象的位置
- 两种方式， 使用句柄 或 直接指针
  1. 句柄
    - 在堆中划出一块作为句柄池
    - 引用里面存句柄的地址
    - 句柄中 包含对象实例数据与类型数据的地址
    - 间接访问
  2. 直接指针
    - 就指针访问
- 使用句柄的好处
  - reference 中储存的是稳定句柄地址
  - 对象被移动时，只改变句柄中的实例数据指针，reference不用被修改
- 直接指针的好处
  - 快，HotSpot是用指针的


## 垃圾回收