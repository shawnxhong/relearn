# 指针
指针都是8个字节，64位机里。
       4个字节，32位机
1. 普通指针
2. 常量指针
    ```c++
    const int v = 10;
    const int *p = &v;
    ```
3. 函数指针
```c++
int add(int a, int b) {
    return a + b;
}
int main() {
    int (*fun_p)(int, int); // 相当于函数声明， fun_p 这个函数指针接受两个int
    fun_p = add;            // 把fun_p 指向 add的地址，fun_p 就能干和add一样的事情了
    cout << fun_p(1,6);
}
```
4. 指向对象的成员
```c++
class A{
public:
    int a, b;
    int add(){
        return a + b;
    }
};
int main() {
    A obj;
    obj.a = 3, obj.b = 4;
    int *p = &obj.a;    // 指向对象的 成员变量

    int (A::*fun_p)();  // 指向对象的 成员函数
    fun_p = &A::add;
    cout << (obj.*fun_p)();  // *fun_p 是取值符号。 因为obj里面没有fun_p, 所以要加个取值符号把那个函数取出来
}

```
5. this 指针
指向类的当前对象
```c++
class A {
	int a;
public:
	void set_a(int tmp) {
		this->a = tmp;
	}
}
```

## 易混淆的
```c++
int *p[10]; // 数组，里面都是 int 指针
int (*p)[10];  // 指针，指向长度10的 int数组
int *p(int);  // 函数签名， 函数名是 p , 接受int 返回int *
int (*p)(int);  // 函数指针， 指向的函数接受int, 返回 int
```

## 野指针 悬空指针
  - 悬空指针： 指针的地方已经被释放了
    - `void *p = malloc(size);`
    - `free(p); `
    - `visit(p);  // 此时 p 已经悬空`
  - 野指针
    - 不知道指向哪里的野生指针

## 指针和引用的区别 *要考*
  - 是否可变
    - 指针指向的空间是可以改变的
    - 引用绑定对象后就不能改变了
  - 是否占内存
    - 指针本身占有内存空间
    - 引用是变量的别名，不占内存
  - 是否可为空
    - 指针可以是空指针
    - 引用必须绑定对象
  - 是否多级
    - 指针可以多级， 指针的指针等
    - 引用只能一级
  - 运算
    - 指针可以运算
    - 引用不能

## 指针常量 & 常量指针 *要考*
- 常量指针
  - 就是个指针
  - 指向一个const 的东西
  - `const int *p;	`
  - `int const *p;  // 反正就是 *p说明这是个指针`
  - 指向的对象 不能通过这个指针来修改
  - 讲传了就是不让你乱改内容的指针
  - 但是他的指向是可以改的
  - 不能乱改的指针

- 指针常量
  - 本质是一个常量
  - 内容是指针
  - `const int var;`
  - `int * const p = &var;	// const p 说明这个是个常量， int * 说明常量内容是个int指针`
  - 因为是const, 所以指向不能变了
  - 里面东西是能改的，但不能乱指
  - 不能乱指的指针

## 函数指针 & 指针函数 *要考*
- 指针函数
  - 本质是函数
  - 返回值是指针

- 函数指针
  - 指向函数的指针

## nullptr 和 NULL 的区别
  - NULL 是一个宏
    - '# define NULL 0'
    - 定义在<cstdlib>
  - nullptr 是一个类型，就是空的指针
    - 所以还是用nullptr 比较安全 


# 左值右值
- 左值
  - 表达式结束后依然持久存在的对象。非临时的
  - 左值引用 & 只能绑左值
- 右值
  - 表达式结束后就不再存在的。 临时的
  - 右值引用 && 只能绑右值
- 通过move 来转换, 只能左转右
- 移动语义
  - 通过定义好拷贝构造函数和赋值构造函数，拷贝一个东西的时候，先把原对象转换成右值临时的，再把右值初始化给新对象。
  - 老对象就直接空了，省去先复制，再销毁老的，这一步
  - `A a2(std::move(a1));`
```c++
int var = 42;
int &left_var = var; // 左值引用
// int &&right_var = var; // error, 左值不能弄右值引用
int &&right_var = var + 40; // ok, 右值引用绑右值

int &&right_2 = std::move(left_var);
```

# 强制类型转换  *要考*
1. static_cast
   - 基本数据类型的转换
   - 子类转父类
   - 空指针 转换为 目标类型
   - 任何类型 转换为 void

2. const_cast 
   - 去除const 属性
   - 将常量指针 转化为 非常量指针
   - 常理引用 转化为 非常量引用 

3. reinterpret_cast
   - 改变指针或引用的类型
   - 将指针或引用 转换为一个足够长度的int
   - 将int 转换为 指针或引用

4. dynamic_cast


# 传参方式的区别
  - 值传递
    - 形参是实参的拷贝。对形参的操作不会影响实参
    - 就是拷贝了一份传进来的参数。之后都是对拷贝在操作
  - 指针传递
    - 也是值传递，但传进来的值是指针
    - 拷贝了一份一模一样的指针
    - 通过拷贝的指针，访问实参的对象，从而修改实参对象的内部。
  - 引用传递
    - 传的是引用。直接可以访问对象内部

