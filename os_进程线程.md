# 计算机操作系统 - 进程管理

## 进程与线程

1. 进程
- 进程是资源分配的基本单位。
- Process Control Block, PCB
  - 描述进程的基本信息和运行状态
  - 所谓的创建进程和撤销进程，都是指对 PCB 的操作。

2. 线程
- 线程是独立调度的基本单位。
- 一个进程中可以有多个线程，它们共享进程资源。
- QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。

3. 区别
- 拥有资源
  - 进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

- 调度
  - 线程是独立调度的基本单位
  - 在同一进程中，线程的切换不会引起进程切换
    - 从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

- 系统开销
  - 由于创建或撤销进程时 要分配或回收资源
    - 内存空间
    - I/O
    - 设备
  - 开销远大于线程开销
  - 进程切换时
    - 执行进程 CPU 环境的保存
    - 新调度进程 CPU 环境的设置
  - 线程切换时
    - 保存和设置少量寄存器内容，开销很小。

- 通信方面
  - 线程间可以通过直接读写同一进程中的数据进行通信
  - 进程通信需要借助 IPC。

## 进程状态的切换

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ProcessState.png)
- 就绪状态（ready）：等待被调度
- 运行状态（running）
- 阻塞状态（waiting）：等待资源

- 就绪态和运行态可以相互转换
  - 就绪状态的进程 通过调度算法 获得 CPU 时间 转为运行状态
  - 运行状态的进程，用完 时间片 转为就绪状态 等待调度
- 进程缺少资源 运行态 -> 阻塞状态

## 进程调度算法

- 批处理系统， 交互式系统， 实时系统，调度算法各不同

### 1. 批处理系统
- 没有太多的用户操作
- 目标是保证吞吐量和周转时间

1.1 *先来先服务 first-come first-serverd*  
- 非抢占式的调度算法
- 按照顺序进行调度。
- 有利于长作业，但不利于短作业

1.2 *短作业优先 shortest job first（SJF）*  

- 非抢占式的调度算法
- 按运行时间最短的顺序进行调度
- 长作业有可能会饿死
  - 短的一直插队

1.3 *最短剩余时间优先 shortest remaining time next（SRTN）*
- 抢占式
- 按剩余运行时间排队
- 来个新的作业 剩余时间 和正在运行的进程的剩余时间 比比
- 谁剩的少谁先，可以抢占

### 2. 交互式系统

- 有大量的用户交互操作
- 目标是快速地进行响应。

2.1 *时间片轮转*  
- 所有就绪进程 先来后到 排成一个队列
- 每人用一个时间片
- 用完回队尾，等下一波
- 效率和时间片的大小有很大关系
  - 涉及上下文切换
  - 时间片太小 -> 一直在切换，浪费时间
  - 时间片过长 -> 不太实时，能感觉到卡顿


2.2 *优先级调度*  
- 每个进程分配一个优先级，按优先级进行调度。
- 低优先级的进程可能永远等不到调度
  - 随着时间的推移 提升低的人的优先级

2.3 *多级反馈队列*
- 一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。
- 多级队列
  - 搞好几个队列 每个的时间片长度不同
  - 1,2,4,8
  - 进程在第一个队列没执行完，就会被移到下一个队列
  - 耗时长的 就能有越多资源  早点搞完
- 每个队列优先权也不同
  - 最上面的优先权最高
  - 上一级队列空的 下面的才能调度

- 时间片轮转 + 优先级


### 3. 实时系统
- 要求一个请求 在一个确定时间内 得到响应
- 分为硬实时和软实时
  - 硬实时 必须满足绝对的截止时间
  - 软实时 可以容忍一定的超时



## 进程同步

### 1. 临界区

- 每个进程在进入临界区之前，需要先进行检查。
```python
entry section;
critical section;
exit section;
```

### 2. 同步与互斥
- 同步
  - 多个进程 共享资源 产生直接制约关系
  - 有先后执行关系

- 互斥
  - 同一时刻 只有一个进程能进入临界区

### 3. 信号量Semaphore
- 一个integer
- *down -> P 操作*
  - if (信号量 > 0)     S --;
  - if (信号量 == 0)    进程睡眠; S 大于 0 时被用完的进程唤醒
- *up   -> V 操作*
  - 退出临界区， S++
  - if (S > 0) 唤醒睡眠的进程;

- down 和 up 操作需要被设计成原语，不可分割
- 通常的做法是在执行这些操作的时候屏蔽中断。

- 信号量的取值只能为 0 或者 1，那么就成为了**互斥量（Mutex）**
  - 0 表示临界区已经加锁
  - 1 表示临界区解锁。


### 4. 管程

- 信号量机制实现的生产者消费者问题 需要客户端代码做很多控制
- 管程把控制的代码独立出来
  - 不容易出错
  - 调用更容易


## 进程通信

- 进程同步与进程通信很容易混淆
  - 区别
    - 进程同步：控制多个进程按一定顺序执行；
    - 进程通信：进程间传输信息。

- 进程通信是一种手段
- 进程同步是一种目的
- 为了达到进程同步，需要让进程进行通信

### 1. 管道

- 通过调用 pipe 函数创建
- fd[0] 用于读
- fd[1] 用于写。

```c
#include <unistd.h>
int pipe(int fd[2]);
```

它具有以下限制：

- 只支持半双工通信（单向交替传输）；
- 只能在父子进程或者兄弟进程中使用。

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png)

### 2. FIFO

- 命名管道
- 去除了管道只能在父子进程中使用的限制。
- FIFO 常用于客户-服务器应用程序中
  - FIFO 用作汇聚点
  - 在客户进程和服务器进程之间传递数据。

```c
#include <sys/stat.h>
int mkfifo(const char *path, mode_t mode);
int mkfifoat(int fd, const char *path, mode_t mode);
```
![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2ac50b81-d92a-4401-b9ec-f2113ecc3076.png)

### 3. 消息队列

- 相比于 FIFO，消息队列 的优点
  - 消息队列可以单独存在 不需要读写进程都开着
    - 从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难
    - 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法
    - 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。

### 4. 信号量

- 计数器
- 控制 多个进程 对共享数据 的访问权限

### 5. 共享存储

- 允许多个进程共享一个给定的存储区
  - 因为数据不需要在进程之间复制，所以这是最快的一种 IPC。

- 需要使用信号量用来同步对共享存储的访问。

- 多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存
  - 另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。

### 6. 套接字

- 与其它通信机制不同的是，它可用于不同机器间的进程通信。

### 7. 信号
- linux 的机制，信号可以在任何时候发送给任意进程
- 信号是软件层次上对中断机制的一种模拟，是一种异步通信方式。
  - 硬件来源：用户按键输入Ctrl+C退出、硬件异常如无效的存储访问等。
  - 软件终止：终止进程信号、其他进程调用kill函数、软件异常产生信号。
- 如果该进程当前并未处于执行状态，则该信号就由内核代为保存，直到该进程恢复执行，内核再把信号传递给它。
- 如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。
- 过程
    1. 信号被某个进程产生，并设置此信号传递的对象（一般为对应进程的pid），然后传递给操作系统；
    2. 操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），如果对应进程没有阻塞，操作系统将传递此信号。
    3. 目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时终止当前代码的执行，保护上下文（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、转而执行中断服务程序，执行完成后在回复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度。


## 进程切换的上下文细节
- 从一个进程切换到另一个进程，要把资源全都备好，这就叫上下文切换
- 上下文信息：指向exe的指针，栈，内存，进程状态，优先级，等等
- 步骤：
   1. 挂起一个进程，将进程在 CPU 中的状态储存于内存中
   2. 在内存中检索下一个进程的上下文，并将其在寄存器中恢复
   3. 跳转到程序计数器所指向的位置，恢复进程
- 上下文切换只发生在内核态中，而且切换带来的CPU时间消耗很大


## 线程切换的上下文细节
- 隶属不同进程的线程切换时，由于资源不共享，切换的过程和进程切换差不多
- 属于同一个进程的线程，切换时只要切换线程私有数据，寄存器，程序计数器