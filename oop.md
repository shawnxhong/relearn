# 面向对象三大机制
- 封装  ：  隐藏内部实现
- 继承  ：  复用现有代码
- 多态  ：  改写对象行为

## 面向对象设计
- 为了复用 -> 抵御变化带来的冲击
- 对象是什么：
  - 从语言层面： 封装了代码和数据
  - 从设计层面： 对象是一系列可以被使用的公共接口
  - 从概念层面： 对象是某种拥有责任的抽象

## 面向对象设计原则
1. 依赖倒置 dependency inversion principle
   - 高层稳定模块 不应依赖于 低层变化模块， 二者都应依赖于稳定的抽象
   - 稳定的抽象不应依赖于实现细节， 实现细节应该依赖于稳定的抽象

2. 开放封闭 open-closed principle
   - 对扩展开放，对更改封闭
   - 一个类一旦开发完成，后续增加新功能不应通过修改这个类来完成，而是通过继承，增加新的类

3. 单一职责原则 single responsibility principle
   - 一个类应该仅有一个引起他变化的原因
   - 变化的方向隐含着类的责任
  
4. 替换原则 Liskov substitution principle
   - 子类必须能够替换他们的基类 （子类有父类的一切特性，父类没有子类的一些特性）
   - 个软件系统中所有用到一个类的地方都替换成其子类，系统应该仍然可以正常工作
  
5. 接口隔离原则 interface segregation principle
   - 不应该强迫客户程序依赖他们不用的方法
   - 接口应小而完备

6. 最少知识原则 least knowledge principle
   - 一个软件实体应尽可能少地与其他实体发生互相作用
   - 一个类应该对自己需要调用的类知道得最少，类的内部如何实现、如何复杂都与调用者或者依赖者没关系
   - 调用者或者依赖者只需要知道他需要的方法即可，其他的我一概不关心。

7. 优先使用对象组合，而不是类继承
   - 类继承为‘白箱复用’， 对象组合为‘黑箱复用’
   - 继承在某种程度上破坏了封装性，子类父类耦合度高
   - 对象组合只要求被组合的对象具有良好的接口，耦合度低

8. 封装变化点
   - 使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一测产生不良影响，实现松耦合。

9. 针对接口编程，而非针对实现编程
   - 不将变量类型声明为某个特定的具体类，而是声明为某个接口。
   - 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口


## 设计经验
1. 设计习语 design idioms
   - 描述与特定编程语言相关的低层模式，技巧，惯用法。

2. 设计模式 Design Patterns
   - 主要描述的是“类与相互通信的对象之间的组织关系，包括它们的角色、职责、协作方式等方面。

3. 架构模式 Architectural Patterns
   - 描述系统中与基本结构组织关系密切的高层模式，包括子系统划分，职责，以及如何组织它们之间关系的规则。

## 设计模式分类
- 从设计目的角度
  - 创建型模式 creational pattern
    - 将对象的部分创建工作延迟到子类或者其他对象，从而应对需求变化为对象创建时具体类型实现引来的冲击
  - 结构型模式 structural pattern
    - 通过类继承或者对象组合获得更灵活的结构，从而应对需求变化为对象的结构带来的冲击。
  - 行为型模式 behavioral pattern
    - 通过类继承或者对象组合来划分类与对象间的职责，从而应对需求变化为多个交互的对象带来的冲击。
- 从范围角度
  - 类模式处理类与子类的静态关系
  - 对象模式处理对象间的动态关系

- 创建型
  - 常用
    - 单例模式
    - 工厂模式 (工厂方法和抽象工厂)
    - 建造者模式
  - 不常用
    - 原型模式
- 结构型
  - 常用
    - 代理模式
    - 桥接模式
    - 装饰者模式
    - 适配器模式
  - 不常用
    - 门面模式
    - 组合模式
    - 享元模式
- 行为型
  - 常用
    - 观察者模式
    - 模板模式
    - 策略模式
    - 职责链模式
    - 迭代器模式
    - 状态模式
  - 不常用
    - 访问者模式
    - 备忘录模式
    - 命令模式
    - 解释器模式
    - 中介模式

## 23招设计模式
- 创建型
  - 常用
    - 单例模式
      - 创建全局唯一的对象。
      - 一个类只能创建一个对象
      - 饿汉式
      - 懒汉式
      - 双重检测
      - 静态内部类
      - 枚举
    - 工厂模式 (工厂方法和抽象工厂)
    - 建造者模式
  - 不常用
    - 原型模式