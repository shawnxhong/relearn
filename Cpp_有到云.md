# C++ 的三大特性，封装，继承，多态

1. 封装 encapsulation
    - 类是支持数据封装的工具，对象是数据封装的实现
    - 类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏
        public大家都能看
        private 只有自己能看
        protected 自己家的能看
    
    - 继承 inheritance
        允许单继承和多继承
        避免公用代码的重复开发，减少代码和数据的冗余
    
    - 多态 polymorphism
      - 以封装和继承为基础
      - 一个接口，多种方法
        
        1. 重载多态，编译期
          - 函数重载
          - 运算符重载
          
        2. 子类型多态，运行期
           - 虚函数
        
        3. 参数多态，编译期
           - 类模板，函数模板
        
        4. 强制多态，编译期/运行期
           - 基本类型转换，自定义类型转换

# C++ 多态
1. 静态多态
   - 编译期，早绑定
```c++
class A {
public:
    void do(int a);
    void do(int a, int b);
};
```
1. 函数重载
   
2. 泛型编程
3. 动态多态

# 虚函数 virtual function declared within a base class to be overriden by derived class
在程序运行时根据基类的引用（指针）指向的对象来确定自己具体该调用哪一个类的虚函数


# 引用和指针的区别
指针是一个存放变量地址的变量，逻辑上是独立的，可以被改变
引用是一个别名，不独立，依赖于其引用对象

# 智能指针有哪些
普通指针可能会出现，用完了没有释放，或者释放过了又再次释放一遍，这样的问题。智能指针用来避免这些情况

shared_ptr
多个指针可以同时指向一个对象，对资源做引用计数，当计数为0的时候，说明没被引用了，自动释放该内存
unique_ptr
独占资源所有权，用完之后自动会释放该内存，不用自己去释放
不允许赋值操作，不能放在等号右边，避免误操作导致指针所有权转移。
weak_ptr
和shared_ptr一起使用。weak_ptr可以看成是shared_ptr所管理的资源的观察者，不具有普通指针的行为，仅仅观察资源的使用情况。当sharedP_ptr 失效后，weak_ptr也失效
用来打破循环引用。循环引用就是：有两个对象， A 和 B，都用了share_ptr，A 要等B死了自己才能死，B要等A死了自己才能死。然后就是这两个都死不掉，内存泄露。
要打破循环引用的话，要么就是手动先宰了一个，剩下的该死的就会死了。要么就是用weak_ptr。
weak_ptr 不会增加引用计数。所以即使weak_ptr还指向一个对象，这个对象的引用计数应该是0的时候就还是0，所以该死的时候就会死。否则一直用share_ptr，引用计数永远降不到0，就永远死不掉。

## 智能指针的实现原理
Resource Acquisition Is Initialization
资源获取即初始化。在类的构造函数中分配资源，在析构函数中释放资源。完成生命周期。
智能指针是一个类，构造函数的时候就增加引用计数，解除引用的时候就减引用计数。然后该释放内存的时候就调用析构函数销毁。
使用智能指针可能发生内存泄漏吗，如何解决
share_ptr 循环引用。死活降不到0，用weak_ptr.
new和malloc的区别
malloc 和 free 是标准库函数。new，delete 是 运算符
malloc 是申请一段长度的内存。new 和 delete会根据类型计算需要的内存大小。
new 从 free store自由存储区上为对象动态分配空间。 malloc 从堆上分配空间
new底层也是malloc实现的
静态成员函数和普通函数的区别
静态成员变量就是，一个static int ，无论创建多少对象，这个static int 都只有一个副本，都指向同一个地方
静态成员函数就是，把这个函数和任何特定对象隔开，这个函数和特定成员没关系。所以即使你没有new 对象，也可以用这个函数。访问方式 classname::
静态成员函数没有this 指针，也只能访问其他的静态成员变量和静态成员函数。
普通函数有this 指针，和对象相关，可以访问静态或非静态的东西。
C++ 的内存管理

code segment：放exe的机器码
data segment：存放已经初始化的全局和静态变量，常数数据
BSS == block started by symbol：存放未初始化的全局和静态变量，（默认为0
堆：从低地址向高地址增长。容量很大。动态分配的东西都在这里面
栈：从高地址向低地址增长。由编译器自动分配。局部变量，函数参数值，返回变量都存在这里。栈的空间小。
函数压栈：一块连续内存压栈，返回时弹出堆栈帧。



内存对齐
变量的起始地址能够被其对齐值整除，结构体变量的对齐值为最宽的成员大小。
结构体每个成员相对于起始地址的偏移能够被其自身对齐值整除，如果不能则在前一个成员后面补充字节。
结构体总体大小能够被最宽的成员的大小整除，如不能则在后面补充字节。
虚函数表存放的内容
如果一个class存在 >= 1个虚函数，这个class就会有个虚函数表
一个subclass 继承并重载了基类的虚函数时，也会有一个自己的虚函数表
我们把某个函数写成虚函数的时候，就是表示希望子类在继承的时候，有自己的实现
如果一个函数不会被继承，就不应该写成虚函数
class A{
    public:
        virtual void vfun1();
        virtual void vfun2();
        void func1();
        void func2();
    private:
        int m_data1[];
}
对虚函数的调用是通过查虚函数表来进行的。查找时通过虚指针来调用。
普通函数不需要表。

一个class如果有虚函数，这个class的大小就会多4个字节，多出来的这个就是个虚指针。指向虚函数表
虚函数表实质上是一个函数指针的数组，每个单元都是虚函数的地址。
一个class的所有object，都公用一份虚函数表
多重继承就是一个人有两个爹，他有几个爹，就有几个虚指针
如果除了继承来的虚函数，自己还有新的虚函数，那就添在爹的表的后面
虚函数表是在编译的时候创建的。
虚函数指针是基于对象的，是在实例化的时候创建的。
什么是纯虚函数
当基类不能对虚函数给出有意义的实现，就把他声明为纯虚函数，具体的实现留给下面的派生去做
只有函数名，参数和返回类型。不需要函数体。
这种class 叫抽象类
class A{
    public:
        A();
        virtual ~A();
        virtual void f1() = 0; //纯虚函数
};
虚函数的实现原理
虚函数表+虚指针
如果派生类重写了基类的虚方法，该派生类虚函数表将保存重写的虚函数的地址，而不是基类的虚函数地址。
如果基类中的虚方法没有在派生类中重写，那么派生类将继承基类中的虚方法，而且派生类中虚函数表将保存基类中未被重写的虚函数的地址。注意，如果派生类中定义了新的虚方法，则该虚函数的地址也将被添加到派生类虚函数表中。
构造函数可以是虚函数吗
不能。虚函数要用虚指针去找，虚指针要实例化的时候才有。实例化的时候要调用构造函数，这时候虚指针都还没有，所以不能是虚函数。
析构函数可以是虚函数吗
可以哦。而且一般析构函数都是虚函数。
将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。
析构函数
析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。
就是用完了自动宰了他
析构函数名也应与类名相同，只是在函数名前面加一个位取反符，例如stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。
class base {
public:
    base() { // 构造函数
        cout << "base constructor" << endl;
    }
    virtual ~base() { // 析构函数
        cout << "base destructor" << endl;
    }
};

class derived : public base {
public:
    derived() {
        cout << "derived constructor" << endl;
    }
    virtual ~derived() {
        cout << "derived destructor" << endl;
    }
};

int main()
{
    base *pBase = new derived; // 爹指向儿子
    cout << "---" << endl;
    delete pBase; // 宰爹的时候一块宰了儿子. 
    // 如果爹的析构函数不是virtual的话, 爹宰了, 儿子还在, 就不行了 

    return 0;
}
什么是模板特化
模板：
函数模板：抽象函数定义，代表一类同构函数
类模板：更高层次的class定义
特化：
模板参数在某种特定类型下的具体实现。
template specialization.
讲穿了就是模板的具体化
就比如说，搞了个判断两个值是否相等的模板
但是不是所有判断相等都可以 == 这样的
int, long long 可以这样, double float 就不能这样 而要 abs( a - b ) < 10e-3 才能判断相等
那就专门把这些特例抽出来，另写个模板，来覆盖这些特殊情况，让你的模板能够覆盖所有数据类型。
这就叫特化。
// 类模板
template <class T1, class T2>
class A{
    T1 data1;
    T2 data2;
}

// 函数模板
template <class T>
T max(const T l, const r){
    return l > r ? l : r;
}
全特化： 通过全特化一个模板，可以对一个特定参数集合自定义当前模板，类模板和函数模板都可以全特化。全特化的模板参数列表应该是空的。应该给出模板实参的列表
// 全特化类模板
template<>
class A<int, double>{ // 
    int data1;
    double data2;
}

//函数模板
template<>
int max(const int l, const int r){
    return l > r ? l : r;
}

如何限制对象只能在堆上创建， 如何限制对象只能在栈上创建
// 创建一个类的对象的两种基本方式
ClassA a1; // 静态创建
ClassA *a2 = new ClassA(); // 动态创建
静态创建： 对象在栈上分配。在栈上直接调用构造函数，形成栈对象。用完之后，编译器自动用析构函数宰了他。
动态创建：在堆上创建。用完之后要自己用delete 宰了他。
创建第一步：执行new() 函数，在堆空间中搜索合适的内存，分配内存
创建第二步：调用构造函数，生出来。
只能在堆上创建对象 == 禁止栈上创建： 把构造函数声明为private
只能在栈上创建对象 == 禁止堆上创建： 重载 new(), 设为private 同时重载 delete() 也private
如何让类不能被继承
final
构造函数和析构函数都定义为private， 然后定义一个public的 static 函数， 内部调用private的构造函数或析构函数。这样就，既不能被继承，但又还是可以正常的实例化。
什么是单例模式，工厂模式
单例模式
确保一个class 只有一个实例，并且自行实例化，向整个程序提供这个实例
（整个游戏就一个神兽）
好处
内存里就这么一个实例，减少内存开支。如果这个东西要频繁的用的，就不要老是一会生一会杀的，就留好这一个，一直留着。
如果这个class 需要的资源比较多的话，就直接单例一个对象，永驻内存，省得浪费
缺点
没有接口，没办法扩展，要修改的话只能改代码
不方便测试，你要测只能等单例的完全写好才能测
class Emperor{
    private static final Emperor e = new Emperor();
    private Emperor(){} // private 构造函数, 使不能乱创建
    public static Emperor getInstance(){
        return e; // 只能这么访问
    } 
    public static void say(){ // 其他函数尽量 static
        cout << "我是秦始皇" << endl;
    }
}
工厂模式
定义一个创建对象的接口，让其子类自己决定实例化哪一个产品类。工厂模式使其创建过程延迟到子类进行
主要解决接口选择问题。明确地计划不同条件下创建的不同实例
简单工厂模式
工厂方法模式
抽象工厂模式
简单工厂模式：即静态工厂方法模式，一个工厂，多个产品。由一个工厂类根据传入的参数，动态地决定应该创建哪一类产品类（这些产品类继承自一个父类或接口）的实例。
#include "stdafx.h"
#include <iostream>

using namespace std;
class Product{
public:
    virtual void show() = 0;//虚基类，纯虚函数
};

class Product_A: public Product{
public:
    void show(){
        cout<<"Product_A"<<endl;
    }
};

class Product_B: public Product{
public:
    void show(){
        cout<<"Product_B"<<endl;
    }
};

class Factory{
public:
    Product* Creat(int i){
        switch (i){
            case 1:
                return new Product_A;
                break;
            case 2:
                return new Product_B;
                break;
            default:
                break;
        }
    }
};

int main(){
    Factory *factory = new Factory();
    factory->Creat(1)->show();
    factory->Creat(2)->show();
    system("pause");
    return 0;
}
C++ auto 类型推导的原理
泛型编程如何实现的
Generic programming
发明一种语言机制，能够帮助实现一个通用的标准容器库。
算法以尽可能抽象的方式编写，而不依赖于将在其上执行这些算法的数据形式
所谓通用的标准容器库，就是要能够做到，比如用一个 List 类存放所有可能类型的对象
sort() 这种也不用管数据类型，可以用于一切迭代器
泛型的语言支持机制就是模板

struct 和 class 的区别
默认的继承访问权限以及成员变量，struct 是public的， class 是 private的
C 和 C++ struct 的区别
C 中，可以定义和struct 重名而不冲突的函数 , void Student(){}
// C 中 定义struct的两种方式
typedef struct Student{
    int age;
} S; // 直接给别名

struct Student{
    int age;
};
typedef struct Student S; // 拆开

void Student(){
    printf("Student\n");
}
C++ 中，定义了struct之后，不需要在调用时声明这是个struct
如果后面再定义了个重名的函数，则这个struct 就不能用了，Student只代表函数。
struct Student{
    int age;
};
void f(Student me); // 可以不说这是struct

强制类型转换有哪些，区别和使用方法
static_cast
基本数据类型转换, int 转 double
儿子转爹
爹转儿子不安全
void * 转成目标类型
任何类型转成 void *
int c = static_cast<int> (7.981); // 基本数据类型之间相互转换
Father *f = new Father;
Son *s;
s = static_cast<Son>(f); // 爹转儿子，不安全
dynamic_cast
别的几个都是编译时完成的，这个是运行时处理的。运行时要类型检查
不能用于基本数据类型的转换。
转换成功的话返回指针，不成功返回null
被转换的基类中一定要有虚函数。因为类型信息存在虚函数表里。你没虚函数就没办法检查类型信息。
爹转儿子安全。
const_cast
不能把类型转换掉, 比如不能把int 转成 double。只能把非const 的转成 const，或者把const 转成非const
reinterpret_cast
随便什么都能转换成别的随便什么。还能转换为指针。不需要考虑类型安全或者是不是常量。就是暴力硬转。不要随便用。

explict 关键字的使用场景
explicit关键字只能修饰只有一个参数的构造函数
或者有多个参数，但是除第一个参数外其他的参数都有默认值的构造函数
它的作用是表明构造函数是显式方式显示的。
class SB{
    public:
        SB(int n){} // 隐式声明
};
SB a(3);
SB b = 10; //如果是隐式的, 这两个都行，SB b = 10相当于 SB b(10);
// 但是看上去像是把 10 赋值给对象。明明是int， 还能等于对象，很怪

// 显式声明
class SB{
    public:
        explicit SB(int n) //显式声明
};

// 这个时候就不能 SB b = 10 了， 一定要SB b(10);
继承时的访问权限控制符有啥区别
public: 谁都能看
protected: 自己家的都能看
private: 只有自己能看
什么是右值引用
用于实现移动语义，完美转发

右值（相对应的还有左值）是从C语言设计时就有的概念，但因为其如此基础，也是一个最常被忽略的概念。不严格的来说，左值对应变量的存储位置，而右值对应变量的值本身。C++中右值可以被赋值给左值或者绑定到引用。类的右值是一个临时对象，如果没有被绑定到引用，在表达式结束时就会被废弃。于是我们可以在右值被废弃之前，移走它的资源进行废物利用，从而避免无意义的复制。被移走资源的右值在废弃时已经成为空壳，析构的开销也会降低。
C++通过拷贝构造函数和拷贝赋值操作符为类设计了拷贝/复制的概念，但为了实现对资源的移动操作，调用者必须使用先复制、再析构的方式。否则，就需要自己实现移动资源的接口。
就是原来对资源的移动，十分傻逼，办法是先复制，在销毁，而不是直接搬运。
右值引用要实现的移动语义就是为了简单点，直接搬运。

引用本质上就是个别名
int a = 5;
a 可以通过 & 取地址, 位于等号左边, a 是左值
5 位于等号右边, 5 没办法通过 & 取地址, 5 是右值
有地址的变量就是左值
没有地址的字面值、临时值就是右值
左值引用
int a = 5;
int &ref_a = a; // 引用指向左值, 编译通过, 引用一个有地址的东西
int &ref_a = 5; // 这个不行, 左值引用指向了右值, 引用一个临时的东西

const int &ref_a = 5; // 这个可以
// const 左值引用不会修改指向值, 所以引用一个临时的东西也没事
右值引用
标志是 && 
右值引用的对象，是临时的，即将被销毁的
并且，右值引用的对象，不会再其他地方使用
int &&ref_a_right = 5; // ok

int a = 5;
int &&ref_a_left = a; // 右值引用不可以指向左值

ref_a_right = 6; // 右值引用的用途, 可以修改右值
std::move 的使用
const 关键字的使用
说明该变量不可以被改变
修饰指针，可以是 pointer to const， 可以是const pointer
修饰引用，reference to const，避免拷贝，避免函数对值的修改
修饰成员函数，说明该成员函数内不能修改成员变量
static 关键字
修饰普通变量，使变量储存在静态区，生命周期为全程
修饰普通函数，表明该函数只能在该文件内部使用。多人开发项目时，避免重名冲突
在class里面，修饰成员变量，使所有对象共享这一个变量，不需要生成对象就可以访问
在class里面，修饰成员函数，所有对象共享这一个函数。static函数内不能访问非静态成员
this 指针
this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。
当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针。
当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。
this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值；在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；
this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &this）。
在以下场景中，经常需要显式引用 this 指针：
为实现对象的链式引用；
为避免对同一对象进行赋值操作；
在实现一些数据结构时，如 list。
sort()底层是怎么实现的
数据量很大的时候，先用快排分段（快排排到底的话，递归会递太深，爆栈）
每段数据<=16个的时候，用插入排序。插入排序对于接近有序的数据，表现接近O(N)
如果已经发现递归得很深了的话，就用堆排序，堆排序绝对是NlogN，稳得一批
快排选轴：三点中值法 -- 选头，尾，中段，三个人之间的中间值。保证选的轴尽量中庸。


java,python,C++的区别？
inline 的作用
相当于把内联函数里面的内容写在调用内联函数处；
相当于不用执行进入函数的步骤，直接执行函数体；
相当于宏，却比宏多了类型检查，真正具有函数特性；
编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；
优点：
inline函数直接在被调用处展开，省去了参数压栈结果返回等等调用开销，速度快
对比宏，inline 会做安全检查，自动类型转换。宏是简单的文字替换
inline 可以调试，宏不可以调试
缺点
inline 造成代码的膨胀。每次调用都会复制代码
对于是否内联，人无法控制。是否进行内联，决定权在于编译器。
virtual 函数可以是inline函数吗
inline virtual是可以的，但当虚函数表现多态性的时候不能内联
inline virtual唯一可以内联的情况是，编译器知道所调用的对象是那个类，这只有在编译器具有实际对象而不是对象的指针或引用的时候在能inline virtual.
volatile
volatile int i = 10;
修饰类型，volatile 就是挥发性，不稳定。
这个东西可能被某些未知因素（操作系统，硬件，其他线程等）更改。声明volatile就是告诉编译器，这个东西就不要优化了。
被volatile 声明过的话，每次访问都是从内存中取值。
普通的没被volatile 声明过的，编译器有可能优化后，就从寄存器里取值。
const可以是volatile。 指针可以是volatile。
讲白了就是这玩意可能有问题，就不要从寄存器里读了，老老实实去内存里读，省的搞错。
assert()
assert 是宏。 如果assert 的条件返回错误，则终止程序执行
#define NDEBUG // 加上这行禁用assert
#include <assert.h>
assert( p != NULL);
sizeof()
sizeof 对数组，得到整个数组占的空间大小
sizeof 对指针，得到指针本身所占空间大小
extern "C"
被extern 限定的函数或变量， 是extern 类型的
被extern "C" 修饰的变量和函数，按照C语言方式编译和链接
作用是让C++编译器将extern "C" 声明的代码当做C语言代码处理。
#ifdef __cplusplus
extern "C" {
#endif

void *memset(void *, int, size_t);

#ifdef __cplusplus
}
#endif
数据结构
vector 底层实现
三个迭代器，指示first, last, end
动态扩容: last == end 的时候，就要扩容。申请大一倍的新空间，再把东西搬过来，再把老空间释放掉。
所以扩容完毕之后，老的迭代器都失效了。因为搬过家了。
为支持快速随机访问，vector是一段连续内存。数组嘛。
map, hashmap 底层实现
红黑树
哈希表
map 的 key 如果是结构体需要注意什么问题
重载小于号。map 是有序的
hash冲突如何解决
链表，或者放旁边
红黑树
根节点必黑
Null 节点必黑
红节点的爹和儿子都必黑
任意一节点到每个叶子节点的路径，包含相同数量的黑节点
并非完美平衡。
B 树
多叉树
主要是为了减少磁盘的访问次数
增删查都是O(h)
扁平，所以访问次数减少